// Generated by CoffeeScript 1.6.2
(function() {
  var ansi, clc, fs, logger, mode, path, readline, sound, _;

  readline = require('readline');

  ansi = require('ansi')(process.stdout);

  _ = require("underscore");

  clc = require('cli-color');

  sound = require("mac-sounds");

  

  fs = require("fs");

  path = require("path");

  mode = "starting";

  logger = {
    messages: [],
    log: function(lvl, msg, options) {
      if (options == null) {
        options = {};
      }
      options = _.defaults(options, {
        color: "black",
        nobreak: false,
        notime: false,
        date: new Date
      });
      options.date = Date.create(options.date);
      lvl = _.isString(lvl) ? lvl : lvl;
      if (!options.notime) {
        ansi.cyan().write(options.date.format("[{h}:{mm}{tt}] ")).reset();
      }
      switch ((_.isString(lvl) ? lvl.toLowerCase() : lvl)) {
        case 0:
        case "error":
          ansi.red().inverse().write("Error").reset().write(" ");
          break;
        case 1:
        case "info":
          ansi.green().inverse().write("Info").reset().write(" ");
          break;
        default:
          ansi[options.color]().write(lvl).reset().write(" ");
      }
      if (_.isString(msg)) {
        ansi.write(msg);
      }
      if (!options.nobreak) {
        return ansi.write("\n");
      }
    },
    clear: function() {
      var _this = this;

      _.each(this.messages, function(args) {
        return _this.log.apply(_this, args);
      });
      return this.messages = [];
    },
    push: function() {
      this.messages.push(_.toArray(arguments));
      if (mode !== "send") {
        return this.clear();
      }
    }
  };

  module.exports = function(argv) {
    var ready, socket, users;

    require("http").get("http://registry.npmjs.org/terminal-chat/latest", function(res) {
      return res.on("data", function(chunk) {
        var data, e, pj;

        try {
          data = JSON.parse(chunk.toString("utf-8"));
          pj = JSON.parse(fs.readFileSync(path.resolve(__dirname, "../package.json"), "utf-8"));
          if (data.version !== pj.version) {
            logger.push("Update", "A newer version of terminal-chat is available.", {
              color: "red"
            });
            return logger.push("Update", "To update, use \"sudo npm update -g terminal-chat\".", {
              color: "red"
            });
          }
        } catch (_error) {
          e = _error;
          return logger.push("error", e.message);
        }
      });
    });
    socket = require('socket.io-client').connect("http://" + argv.host + ":" + argv.port);
    users = {};
    ready = function() {
      var io, setPrompt,
        _this = this;

      io = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: true
      });
      setPrompt = function() {
        var date, len;

        date = Date.create().format("[{h}:{mm}{tt}] ");
        len = (date + argv.user + " > ").length;
        return io.setPrompt(clc.cyan(date) + clc[argv.color](argv.user) + " > ", len);
      };
      setPrompt();
      mode = "receive";
      logger.push("info", "Press enter to chat.");
      io._refreshLine = function() {
        var cols, cursor, line, prevRows, smaller;

        line = (mode === "send" ? this._prompt : "") + this.line;
        cols = line.length % this.columns;
        cursor = this._getCursorPos();
        prevRows = this.prevRows || 0;
        smaller = prevRows < cursor.rows ? prevRows : cursor.rows;
        ansi.previousLine();
        ansi.down();
        ansi.eraseLine();
        _.times(smaller, function() {
          ansi.previousLine();
          return ansi.eraseLine();
        });
        ansi.write(line);
        if (cols === 0 && line.length > 0) {
          ansi.write(" ");
        }
        return this.prevRows = cursor.rows;
      };
      io.on("line", function(line) {
        var args, command_reg, dir, file, fnc, k, m, nv, usernames, v, vk;

        io.history = [];
        if (mode === "receive") {
          command_reg = /^\/([\S]+)/i;
          m = line.match(command_reg);
          ansi.previousLine();
          ansi.eraseLine();
          if (m) {
            args = _.invoke(_.compact(line.replace(m[0], "").trim().split(" ")), "trim");
            switch (m[1]) {
              case "users":
                usernames = _.pluck(users, "name");
                usernames.unshift("you");
                return logger.push("info", "Online Users (" + usernames.length + "): " + (usernames.join(", ")));
              case "set":
                if (args.length >= 2) {
                  vk = ["color", "sound", "silent"];
                  k = args[0];
                  nv = args[1];
                  v = argv[k];
                  if (!_.contains(vk, k)) {
                    return;
                  }
                  if (_.isUndefined(v)) {
                    return;
                  }
                  switch (typeof v) {
                    case "boolean":
                      if (_.contains(["on", "true", "yes"], nv)) {
                        argv[k] = true;
                      } else {
                        argv[k] = false;
                      }
                      break;
                    case "number":
                      argv[k] = parseInt(nv, 10);
                      break;
                    default:
                      argv[k] = nv;
                  }
                  return logger.push("info", k + " => " + argv[k].toString());
                }
                break;
              case "exit":
                logger.push("info", "Goodbye!");
                return process.exit(1);
              default:
                dir = path.resolve(__dirname, "../extras");
                file = _.find(fs.readdirSync(dir), function(file) {
                  var cmd;

                  cmd = path.basename(file, path.extname(file));
                  return cmd === m[1];
                });
                fnc = require(path.join(dir, file));
                if (_.isFunction(fnc)) {
                  return fnc(args, argv, logger, socket);
                }
            }
          } else {
            mode = "send";
            setPrompt();
            return io.prompt();
          }
        } else if (mode === "send") {
          if (line) {
            socket.emit("send", {
              body: line,
              user: socket.socket.sessionid,
              date: Date.create()
            });
          } else {
            ansi.previousLine();
            ansi.eraseLine();
          }
          mode = "receive";
          return logger.clear();
        }
      });
      return socket.on("receive", function(msg) {
        var e, user;

        if (user = users[msg.user]) {
          logger.push(user.name, "> " + msg.body, {
            color: user.color,
            date: msg.date
          });
        } else {
          logger.push("unknown", "> " + msg.body, {
            date: msg.date
          });
        }
        if (!argv.silent) {
          try {
            
          } catch (_error) {
            e = _error;
            return logger.push("error", e.message);
          }
        }
      });
    };
    socket.on('connect', function() {
      logger.push("info", "Connected to server.");
      socket.on("welcome", function(data) {
        var num;

        if (_.isObject(data.users)) {
          users = data.users;
        }
        num = _.size(users);
        return logger.push("info", ("" + num + " user") + (num === 1 ? "" : "s") + " online.");
      });
      socket.on("user.error", function(err) {
        throw new Error(err);
      });
      socket.on("user.success", function() {
        logger.push("info", "Signed in as " + clc[argv.color](argv.user));
        return ready();
      });
      socket.emit("user.register", {
        name: argv.user,
        color: argv.color
      });
      socket.on("user.add", function(user) {
        users[user.id] = user;
        logger.push("info", null, {
          nobreak: true
        });
        return logger.push(user.name, "joined the chat.", {
          color: user.color,
          notime: true
        });
      });
      return socket.on("user.remove", function(id) {
        var user;

        user = users[id];
        logger.push("info", null, {
          nobreak: true
        });
        logger.push(user.name, "left the chat.", {
          color: user.color,
          notime: true
        });
        return delete users[id];
      });
    });
    socket.on('disconnect', function() {
      logger.push("info", "Disconnected from server.");
      return process.exit(1);
    });
    return socket.on('error', function(err) {
      return logger.push("error", err);
    });
  };

}).call(this);

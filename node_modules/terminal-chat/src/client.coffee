readline = require('readline')
ansi = require('ansi')(process.stdout)
_ = require "underscore"
clc = require('cli-color')
sound = require("mac-sounds")
notifier = require('node-notifier')
fs = require "fs"
path = require "path"

mode = "starting"

logger =
	messages: []
	log: (lvl, msg, options = {}) ->
		options = _.defaults options,
			color: "black",
			nobreak: false,
			notime: false,
			date: new Date

		options.date = Date.create(options.date)
		lvl = if _.isString(lvl) then lvl else lvl
		unless options.notime then ansi.cyan().write(options.date.format("[{h}:{mm}{tt}] ")).reset()

		switch (if _.isString(lvl) then lvl.toLowerCase() else lvl)
			when 0, "error" then ansi.red().inverse().write("Error").reset().write(" ")
			when 1, "info" then ansi.green().inverse().write("Info").reset().write(" ")
			else ansi[options.color]().write(lvl).reset().write(" ")

		if _.isString(msg) then ansi.write(msg)
		unless options.nobreak then ansi.write "\n"
	clear: () ->
		_.each @messages, (args) =>
			@log.apply @, args
		@messages = []
	push: () ->
		@messages.push _.toArray(arguments)
		if mode isnt "send" then @clear()

module.exports = (argv) ->

	# check for new version
	require("http").get "http://registry.npmjs.org/terminal-chat/latest", (res) ->
		res.on "data", (chunk) ->
			try
				data = JSON.parse chunk.toString "utf-8"
				pj = JSON.parse fs.readFileSync path.resolve(__dirname, "../package.json"), "utf-8"
				if data.version isnt pj.version
					logger.push "Update", "A newer version of terminal-chat is available.", { color: "red" }
					logger.push "Update", "To update, use \"sudo npm update -g terminal-chat\".", { color: "red" }
			catch e then logger.push "error", e.message

	socket = require('socket.io-client').connect "http://#{argv.host}:#{argv.port}"
	users = {}

	ready = () ->
		io = readline.createInterface { input: process.stdin, output: process.stdout, terminal: true }

		setPrompt = () ->
			date = Date.create().format("[{h}:{mm}{tt}] ")
			len = (date + argv.user + " > ").length
			io.setPrompt clc.cyan(date) + clc[argv.color](argv.user) + " > ", len

		setPrompt()
		mode = "receive"
		logger.push "info", "Press enter to chat."

		io._refreshLine = () ->
			line = (if mode is "send" then this._prompt else "") + this.line
			cols = line.length % this.columns
			cursor = this._getCursorPos()
			prevRows = this.prevRows || 0
			smaller = if prevRows < cursor.rows then prevRows else cursor.rows

			ansi.previousLine()
			ansi.down()
			ansi.eraseLine()

			_.times smaller, () ->
				ansi.previousLine()
				ansi.eraseLine()

			ansi.write line
			if cols is 0 and line.length > 0 then ansi.write " "

			this.prevRows = cursor.rows

		io.on "line", (line) =>
			io.history = [] # make sure nothing is ever saved

			if mode is "receive"
				command_reg = /^\/([\S]+)/i
				m = line.match command_reg
				ansi.previousLine()
				ansi.eraseLine()

				if m
					args = _.invoke(_.compact(line.replace(m[0], "").trim().split(" ")), "trim")

					switch m[1]
						when "users"
							usernames = _.pluck(users, "name")
							usernames.unshift "you"
							logger.push "info", "Online Users (#{usernames.length}): #{usernames.join(", ")}"
						when "set"
							if args.length >= 2
								vk = [ "color", "sound", "silent" ]
								k = args[0]
								nv = args[1]
								v = argv[k]

								unless _.contains(vk, k) then return
								if _.isUndefined(v) then return

								switch typeof v
									when "boolean"
										if _.contains([ "on", "true", "yes" ], nv) then argv[k] = true
										else argv[k] = false
									when "number"
										argv[k] = parseInt(nv, 10)
									else argv[k] = nv

								logger.push "info", k + " => " + argv[k].toString()
						when "exit"
							logger.push "info", "Goodbye!"
							process.exit 1
						else
							dir = path.resolve __dirname, "../extras"
							file = _.find fs.readdirSync(dir), (file) ->
								cmd = path.basename file, path.extname file
								return cmd is m[1]
							fnc = require(path.join(dir,file))
							if _.isFunction(fnc) then fnc(args, argv, logger, socket)

				else
					mode = "send"
					setPrompt()
					io.prompt()

			else if mode is "send"
				if line then socket.emit "send", { body: line, user: socket.socket.sessionid, date: Date.create() }
				else
					ansi.previousLine()
					ansi.eraseLine()
				mode = "receive"
				logger.clear()

		socket.on "receive", (msg) ->
			if user = users[msg.user] then logger.push user.name, "> " + msg.body, { color: user.color, date: msg.date }
			else logger.push "unknown", "> " + msg.body, { date: msg.date }
			
			unless argv.silent
				try 
					sound argv.sound
					notifier.notify
						title: if user then user.name else "Unknown",
						message: msg.body
				catch e
					logger.push "error", e.message
				

	socket.on 'connect', () ->
		logger.push "info", "Connected to server."

		socket.on "welcome", (data) ->
			if _.isObject(data.users) then users = data.users

			num = _.size(users)
			logger.push "info", "#{num} user" + (if num is 1 then "" else "s") + " online."

		socket.on "user.error", (err) -> throw new Error err

		socket.on "user.success", () ->
			logger.push "info", "Signed in as " + clc[argv.color](argv.user)
			ready()

		socket.emit "user.register", { name: argv.user, color: argv.color }  

		socket.on "user.add", (user) ->
			users[user.id] = user
			logger.push "info", null, { nobreak: true }
			logger.push user.name, "joined the chat.", { color: user.color, notime: true }

		socket.on "user.remove", (id) ->
			user = users[id]
			logger.push "info", null, { nobreak: true }
			logger.push user.name, "left the chat.", { color: user.color, notime: true }
			delete users[id]

	socket.on 'disconnect', () ->
		logger.push "info", "Disconnected from server."
		process.exit(1)

	socket.on 'error', (err) ->
		logger.push "error", err